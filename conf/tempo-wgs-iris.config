//
// These should just be the options that do
// _not_ depend on the cluster but the which
// pipeline we are running: wes vs wgs
//
// WGS specific options
//
// This one is hard coded with IRIS specific limits
//

params {
    max_records_in_ram = "5000000" 
}

process {

  time = { task.attempt < 3 ? 48.h * task.attempt  : 167.h }

  withName:CrossValidateSamples {
    cpus = { 2 }
    memory = { 1.GB }
    executor = 'local'
  }
  withName:SplitLanesR1 {
    cpus = { 2 }
    memory = { 1.GB }
  }
  withName:SplitLanesR2 {
    cpus = { 2 }
    memory = { 1.GB }
  }
  withName:AlignReads {
    cpus = { 16 + 8 * task.attempt }
    memory = { 15.GB }
  }
  withName:GATK4SPARK_MARKDUPLICATES {
  // Controlling time by data size, 100 means 100 GB here.
  // maxWallTime and minWall time is set in executor config file
  // based on the queue settings of your cluster
    task.time = { meta.size > 100 ? params.maxWallTime : params.minWallTime }
    cpus = { 16 }
    memory = { (4.GB + (task.attempt).GB) * task.cpus }
  }
  withName:GATK4SPARK_SETNMMDANDUQTAGS {
    task.time = { meta.size > 100 ? params.maxWallTime : params.minWallTime }
    cpus = { 4 }
    memory = { (2.GB + (task.attempt).GB) * task.cpus }
  }
  withName:BQSR_SPLITINTERVALS {
    cpus = { 2 }
    memory = { (1.GB + (task.attempt).GB) * task.cpus }
  }
  withName:GATK4SPARK_BASERECALIBRATOR {
    task.time = { meta.size > 100 ? params.maxWallTime : params.minWallTime }
    cpus = { 4 }
    memory = { (8.GB + (task.attempt).GB) * task.cpus }
  }
  withName:GATK4_GATHERBQSRREPORTS {
    cpus = { 4 }
    memory = { (2.GB + (task.attempt).GB) * task.cpus }
  }
  withName:GATK4SPARK_APPLYBQSR {
    task.time = { meta.size > 100 ? params.maxWallTime : params.minWallTime }
    cpus = { 8 }
    memory = { (8.GB + (task.attempt).GB) * task.cpus }
  }
  withName:'MERGE_SETTAGS_BAM|MERGE_BQSR_BAM' {
    task.time = { meta.size > 100 ? params.maxWallTime : params.minWallTime }
    cpus = { 8 }
    memory = { (2.GB + (task.attempt).GB) * task.cpus }
  }
  withName:'INDEX_SETTAGS_BAM|INDEX_BQSR_BAM' {
    cpus = { 8 }
    memory = { (2.GB + (task.attempt).GB) * task.cpus }
  }
  withName:CreateScatteredIntervals {
    cpus = { 2 }
    memory = { (1.GB * task.attempt) * task.cpus }
  }

  // RunMutect2 is hard coded to take 8Gb in `-Xmx8g`
  // 1 cpu for mutect and and 1 for singularity
  //
  // Also add some resources on subsequent attempts
  // to help if the program is congestion
  //
  withName:RunMutect2 {
    cpus = { 2 + 1 * task.attempt }
    memory = { 10.GB + 5.GB * task.attempt }
  }
  
  withName:SomaticCombineMutect2Vcf {
    cpus = { 1 + 1 * task.attempt }
    memory = { 2.GB + 2.GB * task.attempt }
  }

  withLabel:multiqc_process { // SampleRunMultiQC , SomaticRunMultiQC , CohortRunMultiQC
    cpus = { 4 + 12 * task.attempt }
    memory = { 34.GB * task.attempt }
    time = { task.attempt < 3 ? 30.h * task.attempt : 167.h }
  }

  withName: SomaticRunSVclone {
    cpus = { 4 + 12 * task.attempt }
    memory = { 34.GB * task.attempt }
    time = { task.attempt < 3 ? 30.h * task.attempt : 167.h }
  }

  withName:SomaticAnnotateMaf {
    cpus = { 4 + 12 * task.attempt }
    memory = { 34.GB * task.attempt }
    time = { task.attempt < 3 ? 30.h * task.attempt : 167.h }
  }

  withName:SomaticFacetsAnnotation {
    cpus = { 4 + 12 * task.attempt }
    memory = { 34.GB * task.attempt }
    time = { task.attempt < 3 ? 30.h * task.attempt : 167.h }
  }

  withName:RunPolysolver {
    cpus = { 8 }
    memory = { 16.GB * task.attempt }
  }

  withName:QcQualimap {
    cpus = { 2 }
    memory = { 64.GB * task.attempt } // N.B. Tempo multiples mem by cpu's for this process

    // Calculate what TEMPO actually uses
    clusterOptions = {
      def requestedMem = task.cpus * task.memory.toGiga() * 1.1  // Add 10% buffer
      "--mem=${requestedMem.intValue()}G"
    }

  }


  //
  // SvABA appears to be supper parallel
  // 1561% with 16cpus, try more
  //
  // Just give it the max time, do not want to
  // kill and restart long jobs

  withName: '.*RunSvABA' {
    cpus = { 32 + 5 * task.attempt } // 37, 42, 47, 52
    memory = { 96.GB * task.attempt } // 96, 192, 288, 384
    time = { 167.h }
  }

  withName:RunLOHHLA {
    cpus = { 4 + 12 * task.attempt }
    memory = { 34.GB * task.attempt }
    time = { task.attempt < 3 ? 6.h * task.attempt  : 24.h }
  }

  //
  // Delly takes forever but uses very little
  // resources (probably why it takes forever)
  // so max out on time
  // It seems to need lots of memory so correct
  // for that.
  // Just give it the max time

  withName: SomaticDellyCall {
    cpus = { 2 + 1 * task.attempt }
    memory = { 160.GB * task.attempt } // 160, 320, 480, 640
    time = { 167.h }
  }

  withName: GermlineDellyCall {
    cpus = { 2 + 1 * task.attempt }
    memory = { 160.GB * task.attempt } // 160, 320, 480, 640
    time = { task.attempt < 3 ? 55.h * task.attempt : 167.h }
  }

  //
  // Same with Neoantigen
  //
  withName: RunNeoantigen {
    cpus = { 4 * task.attempt }
    memory = { 160.GB * task.attempt }
    time = { 167.h }
  }

  //
  // Default SLURM config
  //


  withName: 'runBRASS.+' {
    cpus = { 4 + 12 * task.attempt } // 16,28,40,52
    memory = { 246.GB * task.attempt }
    time = { task.attempt < 3 ? 30.h * task.attempt : 167.h }
  }

  withName: runBRASS {
    cpus = { 4 + 12 * task.attempt } // 16,28,40,52
    memory = { 246.GB * task.attempt }
    time = { task.attempt < 3 ? 30.h * task.attempt : 167.h }
  }

  withName: SomaticRunManta {
    cpus = { 4 + 12 * task.attempt } // 16,28,40,52
    memory = { 246.GB * task.attempt }
    time = { task.attempt < 3 ? 30.h * task.attempt : 167.h }
  }

  withName: GermlineRunManta {
    cpus = { 4 + 12 * task.attempt } // 16,28,40,52
    memory = { 246.GB * task.attempt }
    time = { task.attempt < 3 ? 30.h * task.attempt : 167.h }
  }

  withName: SomaticRunStrelka2 {
    cpus = { 4 + 12 * task.attempt } // 16,28,40,52
    memory = { 246.GB * task.attempt }
    time = { task.attempt < 3 ? 30.h * task.attempt : 167.h }
  }

  withName: GermlineRunStrelka2 {
    cpus = { 4 + 12 * task.attempt } // 16,28,40,52
    memory = { 246.GB * task.attempt }
    time = { task.attempt < 3 ? 30.h * task.attempt : 167.h }
  }

  withName: SomaticCombineChannel {
    cpus = { 4 + 12 * task.attempt } // 16,28,40,52
    memory = { 246.GB * task.attempt }
    time = { task.attempt < 3 ? 30.h * task.attempt : 167.h }
  }

  withName: GermlineCombineChannel {
    cpus = { 4 + 12 * task.attempt } // 16,28,40,52
    memory = { 246.GB * task.attempt }
    time = { task.attempt < 3 ? 30.h * task.attempt : 167.h }
  }

  withName: RunMsiSensor {
    cpus = { 4 + 12 * task.attempt } // 16,28,40,52
    memory = { 246.GB * task.attempt }
    time = { task.attempt < 3 ? 30.h * task.attempt : 167.h }
  }

  withName: RunMutationSignatures {
    cpus = { 4 + 12 * task.attempt } // 16,28,40,52
    memory = { 246.GB * task.attempt }
    time = { task.attempt < 3 ? 30.h * task.attempt : 167.h }
  }

  withName: MetaDataParser {
    cpus = { 4 + 12 * task.attempt } // 16,28,40,52
    memory = { 246.GB * task.attempt }
    time = { task.attempt < 3 ? 30.h * task.attempt : 167.h }
  }

  withName: HRDetect {
    cpus = { 4 + 12 * task.attempt } // 16,28,40,52
    memory = { 246.GB * task.attempt }
    time = { task.attempt < 3 ? 30.h * task.attempt : 167.h }
  }

  withName: CohortRunMultiQC {
    cpus = { 4 + 12 * task.attempt } // 16,28,40,52
    memory = { 246.GB * task.attempt }
    time = { task.attempt < 3 ? 30.h * task.attempt : 167.h }
  }

  withName: DoFacets {
    cpus = { 4 + 12 * task.attempt } // 16,28,40,52
    memory = { 246.GB * task.attempt }
    time = { task.attempt < 3 ? 30.h * task.attempt : 167.h }
  }

}
